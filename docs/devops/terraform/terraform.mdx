---
title: 'Terraform'
description: 'Infraestrutura como código'
---

<Info>
  **Pre-requisito** Conhecimento em Cloud, IAAS e Desenvolvimento de Software.
</Info>

<sub>Joel Maykon, criado em 15 de julho 2023</sub>

### Terraform
É uma ferramenta declarativa que serve para provisionar recursos de infraestrutura independente da nuvem que estiver utilizando.
Ele constroi, modifica ou remove os recursos da nuvem, porém ele não gerencia a infraestrutura, podemos usar o ansible por exemplo para
fazer o gerenciamento com base na configuração de infraestrutura definida no terraform. Essa tecnologia foi escrita usando a linguagem Go.

### Componentes do Terraform
- Core: Possui as configurações iniciais e o estado da infraestrutura. Ao executar `terraform plan` é feita uma comparação no estado da
infraestrutura e se houver alguma mudança, os recursos são modificados conforme a definição nas configurações.
- Providers: Definições conforme cada serviço de nuvem, podendo ter diferenças entre ambientes de nuvem.
- Terraform Exec: Software escrito em Go que recebe os comandos para executar o provisionamento dos recursos.
- File.tf ou var.tfvars: Os arquivos terraform possuem a extensão `.tf` ou `.tfvas` que pode ser um único arquivo ou separado em varios arquivos. Exemplos: main.tf,
resources.tf e var.tfvars.
- Plugins: Serve para interagir com os providers e outros tipos de ações que podemos fazer na nossa infraestrutura.
- State: Há um arquivo chamado terraform.state, onde fica os estados da infraestrutura.

### Instalação do Terraform no Linux
 - Podemos usar a documentação do site [HashiCorp Install Terraform](https://developer.hashicorp.com/terraform/downloads) e escolher o sistema operacional que estamos usando.

<CodeGroup>
```bash macOS
brew tap hashicorp/tap
brew install hashicorp/tap/terraform
```

```bash Ubuntu/Debian
wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
sudo apt update && sudo apt install terraform
```
</CodeGroup>

### Estágios do terraform

- Esse comando executamos dentro da pasta onde está os arquivos `.tf` para baixar os providers e recursos declarados.

```bash ubuntu
terraform init
```

- Para validar o código terraform usamos o seguinte comando.

```bash ubuntu
terraform validate
```

- Para planejar nossa infraestrutura com os recursos que serão criados, modificados ou excluidos, usamos o comando abaixo.

```bash ubuntu
terraform plan
```
- Para executar a criação dos recursos no provider (nuvem) que foi definido usamos o código abaixo.

```bash ubuntu
terraform apply
```

- Para deletar a infraestrutura basta executar o seguinte código.

```bash ubuntu
terraform destroy
```

- Para planejar a exclusão da infraestrutura basta executar o seguinte código.

```bash ubuntu
terraform plan destroy
```

- Para mostrar os recursos da infraestrutura basta executar o seguinte código.

```bash ubuntu
terraform show
```

- Para organizar a indentação do código podemos usar o comando abixo.

```bash ubuntu
terraform fmt
```

### Providers

#### Provider Local
- É o responsável para interagir com apis e criar os recursos
- Podemos utilizar o provider local onde temos mais informações no site da [HashiCorp Local Provider](https://registry.terraform.io/providers/hashicorp/local/latest)
```bash .tf
terraform {
  required_providers {
    local = {
      source = "hashcorp/local"
      version = "2.0.0"
    }
  }
}

provider "local" {
  # Configuration options
}
```

#### Provider Random
- Pode ser encontrado a implementação completa desse provider no meu [Github Terraform Ramdon](https://github.com/joelmaykonTADS/apex-brain/tree/main/devops/terraform/random)

- Executamos o comando `terraform init` para baixar o provider.
```bash random.tf
terraform {
  required_providers {
    random = {
      source = "hashicorp/random"
      version = "3.5.1"
    }
  }
}
```
- Para validar o primeiro recursos e validar com `terraform validate`

```bash random.tf
resource "random_string" "random" {
  length = 8
}
```
- Para planejar o recurso definido executamos `terraform plan`
- Criamos com o comando `terraform apply` e digitamos `yes` para confirmar a criação do recurso.
- Para visualizar os recursos criados podemos usar `terraform show`
- Para destruir, primeiro validamos com o `terraform validate` e depois usamos o `terraform destroy`

#### Provider Archive File
- Outro provider interessante é o Archive File que pode ser usado para compactar arquivos.
- O caso de uso abaixo realiza essa tarefa de compactar um arquivo, o projeto esta em [Github Archive Terraform]()
- Usamos os passo para executar esse provider:
  - Iniciar com o comando `terraform init`
  - Validar o archive.tf com `terraform validate`
  - Planejar a infraestrutura `terraform plan`
  - Criar o recurso e executar a compactação com `terraform apply`

```bash archive.tf
terraform {
  required_providers {
    archive = {
      source = "hashicorp/archive"
      version = "2.4.0"
    }
  }
}

data "archive_file" "file_zip" {
  type = "zip"
  source_file = "data_backup/data.txt"
  output_path = "backup.zip"
}

output "file_zip" {
  value = data.archive_file.file_zip.output_size
}
```

#### Multíplos providers

- Podemos ter varios providers num mesmo terraform, veja o projeto [Github Multi Providers](https://github.com/joelmaykonTADS/apex-brain/tree/main/devops/terraform/mult_provider)
- Seguindo os comandos:
  - Iniciar com o comando `terraform init`
  - Validar o multi.tf com `terraform validate`
  - Planejar a infraestrutura `terraform plan`
  - Criar o recurso com `terraform apply`

```bash mult.tf
terraform {
  required_providers {
    archive = {
      source = "hashicorp/archive"
      version = "2.4.0"
    }
    random = {
      source = "hashicorp/random"
      version = "3.5.1"
    }
  }
}

resource "random_string" "random" {
  length = 8
}
# output path this is random string
data "archive_file" "file_zip" {
  type = "zip"
  source_file = "data_backup/data.txt"
  output_path = "${random_string.random.result}.zip"
}

output "file_zip" {
  value = data.archive_file.file_zip.output_size
}

output "random_string" {
  value = random_string.random.result
}
```

#### Provisioners

- Podemos usar os provisioners para executar comando local ou na nuvem

```bash provisioner.tf
resource "null_resource" "bash" {
  provisioner "local-exec" {
    command = "echo testing provisioner terraform!"
  }
}
```
#### Variáveis no terraform

- Criando uma variável
```bash .tfvars
variable "sizeStorage" {
  type = string
  default = "S1"
  description = "Tamanho do Storage"
}
```

- Exemplo do uso
```bash main.tf
provider "azurerm" {
  features {
    
  }
}

variable "location" {
  type = string
  description = "Locale to resources of Azure."
  default = brazilsouth
}

resource "azurerm_resource_group" "apex_group" {
  name     = "apex"
  location = var.location
  tags = var.tags
}
```
- Variáveis do tipo Map para multiplas tags

```bash tags.tf
variable "tags" {
  type = map
  description = "Tags of resources and services azure"
  default = {
    environment = "dev"
    manager = "Joel Maykon"
  }
}
```

- Variáveis do tipo List, criando uma Virtual Network
```bash main.tf
variable "vnet_address" {
  type = list
  default = ["10.0.0.0/16", "192.168.0.0/16"]
}

resource "azurerm_virtual_network" "vnet" {
  name = "vnet-terraform"
  resource_group_name = "${azurerm_resource_group.apex_group.name}"
  location = var.location
  address_space = var.vnet_address
}
```

- Criando outputs para mostrar informações da infraestrutura

```bash main.tf
output "vnet_name" {
  value = "${azurerm_virtual_network.vnet.name}"
}
```

- Usando arquivo .tfvars  `terraform plan -var-file="variables.tfvars"` e o `terraform apply -var-file="variables.tfvars"`
para utilizar as variáveis do arquivo.
```bash variables.tfvars
location = "westus"
name-rg = "apex-dev"
```
- passando o nome da variável por linha de comando por exemplo: `terraform plan -var "location=westus"`
- Podemos usar o merge para unir
```bash main.tf
resource "azurerm_resource_group" "apex_group" {
  name     = var.name-rg
  location = var.location
  tags     = merge(var.tags, { version = "v2.1" })
}
```